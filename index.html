<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Origami Pilot - Hand Tracking Game</title>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB; /* Sky blue fallback */
            font-family: 'Fredoka', sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* Video is hidden, we only use it for logic */
        #input-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 320px;
            height: 240px;
            transform: scaleX(-1); /* Mirror feedback */
            opacity: 0;
            pointer-events: none;
            z-index: 0;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            color: white;
            text-shadow: 2px 2px 0px rgba(0,0,0,0.2);
            font-size: 24px;
        }

        #score-display {
            font-weight: 600;
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 30px;
            backdrop-filter: blur(5px);
        }

        #status-display {
            font-size: 18px;
            opacity: 0.8;
        }

        /* Floating Cards */
        .center-card {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            pointer-events: auto;
            max-width: 90%;
            width: 350px;
            transition: all 0.3s ease;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            transform: translate(-50%, -40%) scale(0.95);
        }

        h1 {
            color: #2c3e50;
            margin: 0 0 10px 0;
            font-size: 32px;
        }

        p {
            color: #7f8c8d;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 50px;
            cursor: pointer;
            font-family: inherit;
            font-weight: 600;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 5px 0 #2980b9;
        }

        button:active {
            transform: translateY(5px);
            box-shadow: none;
        }

        button:disabled {
            background: #bdc3c7;
            box-shadow: none;
            cursor: not-allowed;
        }

        .cam-preview {
            width: 120px;
            height: 90px;
            background: #000;
            margin: 0 auto 20px auto;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .cam-preview video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        /* Loading Spinner */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

    </style>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- Camera Input (Hidden but active) -->
    <video id="input-video"></video>

    <!-- 3D Canvas -->
    <div id="game-container"></div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div class="hud-top">
            <div id="score-display">SCORE: 0</div>
            <div id="status-display">Waiting for camera...</div>
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="center-card">
            <h1>Origami Pilot</h1>
            <p>Use your hand to fly the paper plane. Fly through gold rings for points!</p>
            <div class="cam-preview">
                <!-- We will clone the stream here for UI feedback -->
                <video id="preview-video" autoplay muted playsinline></video>
            </div>
            <button id="start-btn" disabled>Loading AI...</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="center-card hidden">
            <h1>Crashed!</h1>
            <p id="final-score">Score: 0</p>
            <button onclick="resetGame()">Fly Again</button>
        </div>
    </div>

    <script>
        /**
         * ORIGAMI PILOT
         * A hand-tracking flight game using Three.js and MediaPipe
         */

        // --- Configuration ---
        const CONFIG = {
            planeSpeed: 0.8, // Forward speed perception
            steerSpeed: 0.1, // How snappy the plane follows hand
            boundaryX: 25,   // Horizontal movement limit
            boundaryY: 15,   // Vertical movement limit
            spawnRate: 60,   // Frames between spawns
        };

        // --- Global State ---
        let state = {
            isPlaying: false,
            score: 0,
            handDetected: false,
            targetX: 0,
            targetY: 0,
            planePosition: new THREE.Vector3(0, 0, 0),
            frameCount: 0,
            speedMultiplier: 1.0
        };

        // --- Three.js Setup ---
        const container = document.getElementById('game-container');
        const scene = new THREE.Scene();
        // Fog for depth and seamless world generation
        scene.fog = new THREE.Fog(0x87CEEB, 20, 150);
        scene.background = new THREE.Color(0x87CEEB);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, 0, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Optimise for mobile
        container.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- Game Objects ---
        let plane;
        let objects = []; // Holds rings, clouds, enemies

        function createPlane() {
            const group = new THREE.Group();

            // Paper Material
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                roughness: 0.6,
                side: THREE.DoubleSide
            });

            // Main Body (Triangular prism-ish)
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array([
                // Top face
                0, 0, 4,    // Nose
                2, 0.5, -2, // Right wing tip
                -2, 0.5, -2, // Left wing tip
                
                // Bottom spine
                0, -0.5, -2, // Bottom back
                0, 0, 4,     // Nose
                2, 0.5, -2,  // Right wing tip

                0, 0, 4,     // Nose
                -2, 0.5, -2, // Left wing tip
                0, -0.5, -2  // Bottom back
            ]);
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.computeVertexNormals();

            const mesh = new THREE.Mesh(geometry, material);
            group.add(mesh);
            
            // Crease line (visual detail)
            const lineGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 4),
                new THREE.Vector3(0, -0.5, -2)
            ]);
            const lineMat = new THREE.LineBasicMaterial({ color: 0xcccccc });
            const line = new THREE.Line(lineGeo, lineMat);
            group.add(line);

            return group;
        }

        plane = createPlane();
        scene.add(plane);

        // --- Object Spawning (Rings, Clouds) ---
        
        function createCloud() {
            const geometry = new THREE.DodecahedronGeometry(Math.random() * 2 + 1, 0);
            const material = new THREE.MeshFlatMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.8 
            });
            const cloud = new THREE.Mesh(geometry, material);
            
            // Spawn far away
            cloud.position.z = -100;
            // Random X/Y
            cloud.position.x = (Math.random() - 0.5) * 80;
            cloud.position.y = (Math.random() - 0.5) * 40;
            
            // Metadata
            cloud.userData = { type: 'cloud', speed: 0.5 };
            scene.add(cloud);
            objects.push(cloud);
        }

        function createRing() {
            const geometry = new THREE.TorusGeometry(3.5, 0.3, 8, 16);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700, // Gold
                emissive: 0xffaa00,
                emissiveIntensity: 0.5
            });
            const ring = new THREE.Mesh(geometry, material);
            
            ring.position.z = -120;
            ring.position.x = (Math.random() - 0.5) * CONFIG.boundaryX * 1.5;
            ring.position.y = (Math.random() - 0.5) * CONFIG.boundaryY * 1.5;

            ring.userData = { type: 'ring', active: true, rotationSpeed: Math.random() * 0.05 };
            scene.add(ring);
            objects.push(ring);
        }

        function createObstacle() {
            // Red Block
            const geometry = new THREE.BoxGeometry(4, 4, 4);
            const material = new THREE.MeshStandardMaterial({ color: 0xe74c3c });
            const block = new THREE.Mesh(geometry, material);

            block.position.z = -120;
            block.position.x = (Math.random() - 0.5) * CONFIG.boundaryX * 1.5;
            block.position.y = (Math.random() - 0.5) * CONFIG.boundaryY * 1.5;

            // Random rotation
            block.rotation.set(Math.random(), Math.random(), Math.random());

            block.userData = { type: 'obstacle', active: true };
            scene.add(block);
            objects.push(block);
        }

        // --- Physics & Logic ---

        function checkCollision(obj) {
            if (!obj.userData.active) return;

            // Simple distance check
            const dist = plane.position.distanceTo(obj.position);

            if (obj.userData.type === 'ring') {
                if (dist < 4) { // Plane flew through
                    obj.userData.active = false;
                    obj.scale.set(0.1, 0.1, 0.1); // Shrink effect
                    addScore(100);
                    // Visual pop
                    createParticles(obj.position, 0xFFD700);
                }
            } else if (obj.userData.type === 'obstacle') {
                if (dist < 3) {
                    gameOver();
                }
            }
        }

        function createParticles(pos, color) {
            // Simple particle burst
            // In a full game, we'd use a particle system. 
            // Here, we just flash the screen slightly or change UI for simplicity/performance
            const flash = document.createElement('div');
            flash.style.position = 'absolute';
            flash.style.top = '0'; flash.style.left = '0';
            flash.style.width = '100%'; flash.style.height = '100%';
            flash.style.background = 'white';
            flash.style.opacity = '0.3';
            flash.style.pointerEvents = 'none';
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 100);
        }

        function updateObjects() {
            state.frameCount++;
            
            // Spawn logic
            if (state.frameCount % CONFIG.spawnRate === 0) {
                const r = Math.random();
                if (r < 0.3) createCloud();
                else if (r < 0.7) createRing();
                else createObstacle();
            }

            // Move & Clean objects
            for (let i = objects.length - 1; i >= 0; i--) {
                const obj = objects[i];
                
                // Move towards camera
                // Clouds move slower for parallax effect
                const speed = obj.userData.type === 'cloud' ? 0.3 : 1.2 * state.speedMultiplier;
                obj.position.z += speed;

                // Rotation for aesthetic
                if (obj.userData.type === 'ring') {
                    obj.rotation.z += obj.userData.rotationSpeed;
                } else if (obj.userData.type === 'obstacle') {
                    obj.rotation.x += 0.02;
                    obj.rotation.y += 0.02;
                }

                // Check collision if it's close enough (z > -5 and z < 5)
                if (obj.position.z > -5 && obj.position.z < 5) {
                    checkCollision(obj);
                }

                // Remove if behind camera
                if (obj.position.z > 20) {
                    scene.remove(obj);
                    objects.splice(i, 1);
                }
            }
        }

        function updatePlane() {
            // Smoothly interpolate current position to target position derived from hand
            // Lerp factor
            const alpha = 0.1; 
            
            state.planePosition.x += (state.targetX - state.planePosition.x) * alpha;
            state.planePosition.y += (state.targetY - state.planePosition.y) * alpha;

            plane.position.copy(state.planePosition);

            // Calculated Bank (Roll) and Pitch based on velocity
            // If moving Left, Bank Left. If moving Up, Pitch Up.
            
            const dx = state.targetX - plane.position.x;
            const dy = state.targetY - plane.position.y;

            // Roll: negative dx = bank left (positive rotation Z)
            const targetRoll = -dx * 0.5; // Multiplier for visual flair
            const targetPitch = dy * 0.3;

            plane.rotation.z += (targetRoll - plane.rotation.z) * 0.1;
            plane.rotation.x += (targetPitch - plane.rotation.x) * 0.1;
        }

        // --- Game Loop ---

        function animate() {
            requestAnimationFrame(animate);

            if (state.isPlaying) {
                updatePlane();
                updateObjects();
            } else {
                // Idle animation when paused
                plane.position.y = Math.sin(Date.now() * 0.002) * 1;
                plane.rotation.z = Math.sin(Date.now() * 0.001) * 0.1;
            }

            renderer.render(scene, camera);
        }

        // --- MediaPipe Hand Tracking ---

        const videoElement = document.getElementById('input-video');
        const previewVideo = document.getElementById('preview-video');
        const statusDisplay = document.getElementById('status-display');
        const startBtn = document.getElementById('start-btn');

        function onResults(results) {
            // Hide loading status if it's the first frame
            if (!state.handDetected && results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handDetected = true;
                statusDisplay.innerText = "Hand detected! Ready to fly.";
                statusDisplay.style.color = "#2ecc71";
            } else if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                 statusDisplay.innerText = "Show your hand to control...";
                 statusDisplay.style.color = "white";
            }

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // We use the wrist (0) or average of palm for stability
                // Let's use Index Finger MCP (5) and Wrist (0) average
                const x = (landmarks[0].x + landmarks[5].x + landmarks[17].x) / 3;
                const y = (landmarks[0].y + landmarks[5].y + landmarks[17].y) / 3;

                // MediaPipe coords are normalized [0,1]. X is mirrored already by MP or CSS? 
                // MP Output: x=0 is left, x=1 is right.
                // We mirrored the video with CSS, but the coordinates come raw. 
                // Usually, for intuitive control:
                // Move hand Right (your physical right) -> Camera sees Left side of image -> x approaches 0.
                // We want plane to go Right (Positive X).
                // So: (1 - x) maps 0->1 (Left->Right).
                
                // Map [0, 1] to [-boundary, boundary]
                const mappedX = (1 - x) * CONFIG.boundaryX * 2 - CONFIG.boundaryX;
                const mappedY = (1 - y) * CONFIG.boundaryY * 2 - CONFIG.boundaryY;

                state.targetX = mappedX;
                state.targetY = mappedY;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // --- Camera Setup ---

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        // Start camera and logic
        cameraUtils.start()
            .then(() => {
                startBtn.disabled = false;
                startBtn.innerText = "Start Engine";
                
                // Clone stream for preview
                if(videoElement.srcObject) {
                    previewVideo.srcObject = videoElement.srcObject;
                }
            })
            .catch(err => {
                console.error(err);
                statusDisplay.innerText = "Camera access denied or error.";
            });


        // --- UI & Controls ---

        function addScore(points) {
            state.score += points;
            document.getElementById('score-display').innerText = `SCORE: ${state.score}`;
            
            // Speed up slightly
            if(state.speedMultiplier < 2.0) {
                state.speedMultiplier += 0.02;
            }
        }

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            
            state.score = 0;
            state.speedMultiplier = 1.0;
            state.isPlaying = true;
            document.getElementById('score-display').innerText = `SCORE: 0`;

            // Clear old objects
            objects.forEach(obj => scene.remove(obj));
            objects = [];
        }

        function gameOver() {
            state.isPlaying = false;
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('final-score').innerText = `Final Score: ${state.score}`;
        }

        function resetGame() {
            startGame();
        }

        startBtn.addEventListener('click', startGame);

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation loop
        animate();

    </script>
</body>
</html>